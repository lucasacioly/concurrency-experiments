package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"math/rand"
	"net/rpc"
	"os"
	"strconv"
	"time"

	"github.com/streadway/amqp"
)

type NumbersRequest struct {
	Numbers []int
}

type NumbersResponse struct {
	PrimeNumbers    []int
	NonPrimeNumbers []int
}

const NUM_REPS = 10000
const TAM_AMOSTRA = 3000
const RANGE = 1500

const NUM_REPS_DEMO = 5
const TAM_AMOSTRA_DEMO = 20
const RANGE_DEMO = 50

func connectToRabbitMQ() (*amqp.Connection, *amqp.Channel, error) {
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/") // Update with your RabbitMQ server details
	if err != nil {
		return nil, nil, err
	}

	ch, err := conn.Channel()
	if err != nil {
		return nil, nil, err
	}

	return conn, ch, nil
}

func errorFound(err error) {
	if err != nil {
		fmt.Println("Fatal error: ", err)
		os.Exit(1)
	}
}

func generateRandomNumbers(count int, baseSeed int64, interval int) []int {
	numbers := make([]int, count)
	seed := baseSeed
	rand.Seed(seed)
	for i := 0; i < count; i++ {
		seed += int64(i)
		rand.Seed(seed)
		numbers[i] = rand.Intn(interval) + 1
	}
	return numbers
}

func serverConnectionDemo(client *rpc.Client) {

	// generate random numbers
	numbers := generateRandomNumbers(TAM_AMOSTRA_DEMO, 81, 50)

	for i := 0; i < NUM_REPS_DEMO; i++ {
		// Call the RPC method on the server
		var resp NumbersResponse
		err := client.Call("PrimeService.GetPrimeNumbers", NumbersRequest{Numbers: numbers}, &resp)
		errorFound(err)

		// Display prime and non-prime numbers
		fmt.Println("Prime Numbers:", resp.PrimeNumbers)
		fmt.Println("Non-Prime Numbers:", resp.NonPrimeNumbers)
	}
}

/*
func serverConnection(client *rpc.Client, clientID int, numClients int) {

	// generate random numbers
	numbers := generateRandomNumbers(TAM_AMOSTRA, 81, TAM_AMOSTRA/2)

	// Open file for writing
	fileName := fmt.Sprintf("RPC_elapsed_time_client_%d_%d.txt", numClients, clientID)
	file, err := os.Create(fileName)
	errorFound(err)

	for i := 0; i < NUM_REPS; i++ {
		startTime := time.Now().UnixNano()

		// Call the RPC method on the server
		var resp NumbersResponse
		err := client.Call("PrimeService.GetPrimeNumbers", NumbersRequest{Numbers: numbers}, &resp)
		errorFound(err)

		elapsedTime := time.Now().UnixNano() - startTime
		_, err = file.WriteString(fmt.Sprintf("%d\n", elapsedTime))

		// Display prime and non-prime numbers
		fmt.Println(clientID, " Prime Numbers:", resp.PrimeNumbers)
		fmt.Println(clientID, " Non-Prime Numbers:", resp.NonPrimeNumbers)
	}
}*/

func serverConnection(conn *amqp.Connection, ch *amqp.Channel, clientID int, numClients int) {

	// generate random numbers
	numbers := generateRandomNumbers(TAM_AMOSTRA, 81, TAM_AMOSTRA/2)

	// Open file for writing
	fileName := fmt.Sprintf("RPC_elapsed_time_client_%d_%d.txt", numClients, clientID)
	file, err := os.Create(fileName)
	errorFound(err)

	ReplyQueue, err := ch.QueueDeclare(
		"",    // Name generated by RabbitMQ
		false, // Durable
		false, // Delete when unused
		true,  // Exclusive
		false, // No-wait
		nil,   // Args
	)
	errorFound(err)

	// Cria fila para consumir mensagens
	msgs, err := ch.Consume(
		ReplyQueue.Name, // Queue name
		"",              // Consumer
		true,            // Auto-ack
		false,           // Exclusive
		false,           // No-local
		false,           // No-wait
		nil,             // Args
	)
	errorFound(err)

	for i := 0; i < NUM_REPS; i++ {
		request := NumbersRequest{Numbers: numbers}
		requestBytes, err := json.Marshal(request)
		if err != nil {
			log.Printf("Error encoding request: %v", err)
			continue
		}

		startTime := time.Now().UnixNano()

		err = ch.Publish(
			"",            // Exchange
			"prime_queue", // Routing key
			false,         // Mandatory
			false,         // Immediate
			amqp.Publishing{
				ContentType:   "application/json",
				CorrelationId: strconv.Itoa(i),
				ReplyTo:       ReplyQueue.Name,
				Body:          requestBytes,
			})
		errorFound(err)

		// recebe mensagem do servidor de mensageria
		m := <-msgs

		elapsedTime := time.Now().UnixNano() - startTime
		_, err = file.WriteString(fmt.Sprintf("%d\n", elapsedTime))

		var response NumbersResponse
		err = json.Unmarshal(m.Body, &response)
		if err != nil {
			log.Printf("Error decoding response: %v", err)
			continue
		}

		// Display prime and non-prime numbers
		fmt.Println("Prime Numbers:", response.PrimeNumbers)
		fmt.Println("Non-Prime Numbers:", response.NonPrimeNumbers)
	}
}

func main() {
	numClients := flag.Int("clients", 1, "Number of clients")
	clientID := flag.Int("id", 0, "Client ID")
	flag.Parse()

	conn, ch, err := connectToRabbitMQ()
	errorFound(err)
	defer conn.Close()
	defer ch.Close()

	serverConnection(conn, ch, *clientID, *numClients)
	//serverConnectionDemo(client, numbers)
}
